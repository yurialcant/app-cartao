package com.benefits.core.service;

import com.benefits.core.entity.Wallet;
import com.benefits.core.repository.WalletRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;
import java.math.BigDecimal;
import java.util.UUID;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class WalletServiceTest {

    @Mock
    private WalletRepository walletRepository;

    @InjectMocks
    private WalletService walletService;

    private UUID tenantId;
    private UUID personId;
    private UUID employerId;
    private Wallet wallet;

    @BeforeEach
    void setUp() {
        tenantId = UUID.randomUUID();
        personId = UUID.randomUUID();
        employerId = UUID.randomUUID();

        wallet = new Wallet();
        wallet.setId(UUID.randomUUID());
        wallet.setTenantId(tenantId);
        wallet.setPersonId(personId);
        wallet.setEmployerId(employerId);
        wallet.setBalance(BigDecimal.valueOf(1000.00));
        wallet.setCurrency("BRL");
        wallet.setActive(true);
    }

    @Test
    void getWalletByPersonId_shouldReturnWallet() {
        // Given
        when(walletRepository.findByTenantIdAndPersonIdAndEmployerId(tenantId, personId, employerId))
            .thenReturn(Mono.just(wallet));

        // When
        Mono<Wallet> result = walletService.getWalletByPersonId(tenantId, personId, employerId);

        // Then
        StepVerifier.create(result)
            .expectNext(wallet)
            .verifyComplete();
    }

    @Test
    void createWallet_shouldSaveAndReturnWallet() {
        // Given
        when(walletRepository.save(any(Wallet.class))).thenReturn(Mono.just(wallet));

        // When
        Mono<Wallet> result = walletService.createWallet(tenantId, personId, employerId);

        // Then
        StepVerifier.create(result)
            .expectNext(wallet)
            .verifyComplete();
    }

    @Test
    void creditWallet_shouldUpdateBalance() {
        // Given
        BigDecimal amount = BigDecimal.valueOf(500.00);
        when(walletRepository.findByTenantIdAndPersonIdAndEmployerId(tenantId, personId, employerId))
            .thenReturn(Mono.just(wallet));
        when(walletRepository.save(any(Wallet.class))).thenReturn(Mono.just(wallet));

        // When
        Mono<Wallet> result = walletService.creditWallet(tenantId, personId, employerId, amount);

        // Then
        StepVerifier.create(result)
            .expectNextMatches(w -> w.getBalance().compareTo(BigDecimal.valueOf(1500.00)) == 0)
            .verifyComplete();
    }

    @Test
    void debitWallet_shouldUpdateBalance() {
        // Given
        BigDecimal amount = BigDecimal.valueOf(300.00);
        when(walletRepository.findByTenantIdAndPersonIdAndEmployerId(tenantId, personId, employerId))
            .thenReturn(Mono.just(wallet));
        when(walletRepository.save(any(Wallet.class))).thenReturn(Mono.just(wallet));

        // When
        Mono<Wallet> result = walletService.debitWallet(tenantId, personId, employerId, amount);

        // Then
        StepVerifier.create(result)
            .expectNextMatches(w -> w.getBalance().compareTo(BigDecimal.valueOf(700.00)) == 0)
            .verifyComplete();
    }

    @Test
    void debitWallet_insufficientFunds_shouldThrowException() {
        // Given
        BigDecimal amount = BigDecimal.valueOf(1500.00); // More than balance
        when(walletRepository.findByTenantIdAndPersonIdAndEmployerId(tenantId, personId, employerId))
            .thenReturn(Mono.just(wallet));

        // When
        Mono<Wallet> result = walletService.debitWallet(tenantId, personId, employerId, amount);

        // Then
        StepVerifier.create(result)
            .expectError(IllegalArgumentException.class)
            .verify();
    }
}